---
title: "intro-vignette: scEnrich"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
This vignette introduces how to use the `scEnrich` (the name needs updating) package to discover associated cell types with disease from a single-cell RNA-seq data set. `scEnrich` will interact with the `SingleCellExperiment` object. Here is the vignette of the recommended workflow. The required data are:
- A matrix or `SingleCellExperiment` object as the expression data set.
- Cell meta data for the cell type/region annotation.
- A processed disease MAGMA z-score file. We also provide some scripts for the processing step.
All results will be stored as meta data in the object.

## Load package and data
All the data was nested in a `SingleCellExperiment` object. The example data is from [The Tabula Muris Consortium](https://www.nature.com/articles/s41586-018-0590-4). The processed form of the data set can be found by the link of the website. 
```{r, message=FALSE, warning=FALSE}
library(scEnrich)
library(magrittr)
library(SingleCellExperiment)
library(tidyverse)
library(ggplot2)
library(patchwork)
#this data can be downloaded online
load("/grain/ql29/ad-cell-enrich/data/expr/Tabula_muris/facs/facs.sce.rda")
```

## Preprocess data
Cells with low We use `scran` package for the estimation of size factors which are further employed to normalize the expression data. Before normalization, cells with low quality should be removed. For this data sets, the cells with fewer counts and higher mitochondrial RNA ratio have been removed. Thus we directly start with `scran` normalization.
```{r message=FALSE,warning=FALSE}
library(scran)
#cluster
cluster.assign = quickCluster(facs.sce) 
#size factor calculation
size.factor = calculateSumFactors(facs.sce, cluster=cluster.assign, min.mean = 0.1)
#normalize
facs.sce = logNormCounts(facs.sce, size.factors = size.factor)
```

## Calculate basic statistics and specificity score
Basic cell group-level statistics are required for later specificity score gene summary statistics calculation. In this step, the `SingleCellExperiment` object and the matched cell meta data (a `data.frame` or `tibble`) is required. The order of cells in the meta data (as in each row) should correspond to the order of cells in the object (as in each column). When no meta data is provided, the colData of the object will be represented as the meta data. For cells with too few cells, we filter such groups out since such group may be contaminants or outliers and lack the statistical power.
```{r message=FALSE,warning=FALSE}
#calculate basic statistics 
facs.sce = cal_stat(data_obj = facs.sce, meta_data = as.data.frame(colData(facs.sce)), group = "cluster_name")
#calculate specificity score
facs.sce = cal_sscore(data_obj = facs.sce) 
#choosing out groups can be added here 
```

## Set gene filter or merge 
Since this is a mouse data set, mapping genes between species is essential. This can be done by `sscore_mmu_hsa` function. For this step, specificity score will be averaged across all mouse genes with the human gene Entrez ID. Also, if you would like to map the the data matrix (counts or normalized format) before calculating specificity score, you may use the `munge_sce_mat` function (to be done) to achieve this. We provide the set of mouse gene id to human gene id mapping from biomart. This parsed data table can be easily loaded. Even if you use human gene symbols as feature names, mapping to human entrez id is also supposed to be done here. (We only keep genes with Entrez ID). 
```{r message=FALSE,warnings=FALSE}
#load processed biomaRt mmu and hsa gene mapping
data("mmu_hsa_mapping")  
#map mmu genes to hsa genes
facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
#calculate global statics
facs.sce = add_glob_stats(facs.sce, stats = c("det_cell_num","ave_exp_ct","max_exp_ct") ) 
#or you can add some more statistics yourself
```

## Cell-type enrichment
Finally the cell type specificity score can be used to determine
```{r}
#load MAGMA z-score file
t2d_zscore = load_zscore("/grain/ql29/ad-cell-enrich/data/gwas/Morris_2012/T2D.35.10.genes.out")
mdd_zscore = load_zscore("/grain/ql29/ad-cell-enrich/data/gwas/Howard_2019/MDD.35.10.genes.out")
#perform cell type enrichment analysis 
facs.sce = ct_asso(facs.sce, t2d_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
facs.sce = ct_asso(facs.sce, mdd_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
```

## Visualization
Final we can visualize the results. The plot is a `ggplot` object and could be further customized. 
If you would like to add some grouping to the plot, you may use `add_cell_anno()` function to add the cell type annotation to the enrichment results and visualize with the `group_by` argument. 
```{r,fig.width=8, fig.height=10, fig.align = 'center'}
#plot
f1 = plot_asso(facs.sce, trait="T2D",plot_top_option = "rank<=15") + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f2 = plot_asso(facs.sce, trait = "MDD", plot_top_option = "rank<=15") + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5))

f1/f2
```


```{r,fig.width=8, fig.height=10,fig.align = 'center'}
#if you would like to add more to the plot, for example, the tissue type
celltype_tissue = colData(facs.sce) %>% as_tibble() %>%  distinct(cluster_name, tissue) #annotation
facs.sce = add_ct_anno(facs.sce,  celltype_tissue, match_col="cluster_name")
#plot for the two
f3 = plot_asso(facs.sce, trait="T2D", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f4 = plot_asso(facs.sce, trait="MDD", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5)) 
f3/f4
```


## Varying background cell types
When calculating specificity score, the choice of background cells for a cell type is crucial. By default all cells of the other cell types are treated as the background cell type. But for these cells that are quite similar to each other (for example, cell types of an ontology that are either descendant or ancestor node in the cell ontology tree) this may cancel out the gene specificity score. The `out_group_mat` parameter of the `cal_sscore` function may be used to describe what cell types should be regarded as the background cells for a cell type, in a binary adjacency matrix format,  with each entry in the matrix indicating whether the corresponding cell type in the column is the background cells for cell type in the row. Here is an example on how to utilized an annotated cell ontology relationship to define background cells by removing cell types of either descendant or ancestor node in the tree.
```{r,fig.width=8, fig.height=10, fig.align = 'center'}
#load the annotated cell ontology table  #this step is performed using external python session since obonet is only supported in python
co_anno_table = read.csv("/grain/ql29/ad-cell-enrich/data/expr/Tabula_muris/cell_ontology_annotated_new_all.csv") %>% as_tibble()
#create the adjacency matrix
co_out_mat = co_anno_table %>%
  right_join(as.data.frame(colData(facs.sce)) %>% distinct(cluster_name, cell_ontology_id), by=c("cl_term" = "cell_ontology_id")) %>% #join annotation
  filter(cluster_name %in% names(metadata(facs.sce)[["group_info"]][["cell_num"]])) %>%  #filter cell types that exist in the final results
  mutate(cluster_name = factor(cluster_name, levels = sort(cluster_name))) %>% 
  arrange(cluster_name) %>% #make sure the matrix is in the same order of the sorted cluster names
  apply(., 1, function(x) !grepl(pattern=x[1], x=.$similar_cl_term, fixed=T) & x[1]!=.$cl_term )  %>%
  set_rownames(sort( names(metadata(facs.sce)[["group_info"]][["cell_num"]]))) %>%
  set_colnames(sort( names(metadata(facs.sce)[["group_info"]][["cell_num"]])))
#calculate specificity score, translate gene id and perform association analysis
facs.sce = cal_sscore(data_obj = facs.sce, out_group_mat =  co_out_mat) 
## the group-level statistics have been translate into human gene id level you could also re-compute the statistics, specificity score and then map to human gene id
#facs.sce = cal_stat(data_obj = facs.sce, meta_data = as.data.frame(colData(facs.sce)), group = "cluster_name")
#facs.sce = cal_sscore(data_obj = facs.sce,  out_group_mat =  co_out_mat)
#facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
##
facs.sce = ct_asso(facs.sce, t2d_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
facs.sce = ct_asso(facs.sce, mdd_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")

#final plot
f5 = plot_asso(facs.sce, trait="T2D", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f6 = plot_asso(facs.sce, trait="MDD", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5)) 
f5/f6
```
Here the results are quite similar to the former ones (without specifying background cells).

