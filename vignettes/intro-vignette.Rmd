---
title: "intro-vignette: seismicGWAS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
This vignette introduces how to use the `seismicGWAS` package to discover associated cell types with disease from a single-cell RNA-seq data set. `seismicGWAS` will interact with the `SingleCellExperiment` object. Here is the vignette of the recommended workflow. The required data are:
- A matrix or `SingleCellExperiment` object as the expression data set.
- Cell meta data for the cell type/region annotation.
- A processed disease MAGMA z-score file. We also provide some scripts for the processing step.
All results will be stored as meta data in the object.k

## Load package and data
All the data was nested in a `SingleCellExperiment` object. The example data is from [The Tabula Muris Consortium](https://www.nature.com/articles/s41586-018-0590-4). The processed form of the data set can be found by the link of the website. 
```{r, message=FALSE, warning=FALSE}
library(seismicGWAS)
library(magrittr)
library(SingleCellExperiment)
library(tidyverse)
library(ggplot2)
library(patchwork)
#this data can be downloaded online
load("/grain/ql29/ad-cell-enrich/data/expr/Tabula_muris/facs/facs.sce.rda")
```

## Preprocess data
We use `scran` package for the estimation of size factors which are further employed to normalize the expression data. Before normalization, cells with low quality should be removed. For this data sets, the cells with fewer counts and higher mitochondrial RNA ratio have been removed. Thus we directly start with `scran` normalization.
```{r message=FALSE,warning=FALSE}
library(scran)
#cluster
cluster.assign = quickCluster(facs.sce) 
#size factor calculation
size.factor = calculateSumFactors(facs.sce, cluster=cluster.assign, min.mean = 0.1)
#normalize
facs.sce = logNormCounts(facs.sce, size.factors = size.factor)
```

## Calculate basic statistics and specificity score
Basic cell group-level statistics are required for later specificity score gene summary statistics calculation. In this step, the `SingleCellExperiment` object and the matched cell meta data (a `data.frame` or `tibble`) is required. The order of cells in the meta data (as in each row) should correspond to the order of cells in the object (as in each column). When no meta data is provided, the colData of the object will be represented as the meta data. For cells with too few cells, we filter such groups out since such group may be contaminants or outliers and lack the statistical power.
```{r message=FALSE,warning=FALSE}
#calculate basic statistics 
facs.sce = cal_stat(data_obj = facs.sce, meta_data = as.data.frame(colData(facs.sce)), group = "cluster_name")
#calculate specificity score
facs.sce = cal_sscore(data_obj = facs.sce) 
#choosing out groups can be added here 
```

## Set gene filter or merge 
Since this is a mouse data set, mapping genes between species is essential. This can be done by `sscore_mmu_hsa` function. For this step, specificity score will be averaged across all mouse genes with the human gene Entrez ID. Also, if you would like to map the the data matrix (counts or normalized format) before calculating specificity score, you may use the `munge_sce_mat` function (to be done) to achieve this. We provide the set of mouse gene id to human gene id mapping from biomart. This parsed data table can be easily loaded. Even if you use human gene symbols as feature names, mapping to human entrez id is also supposed to be done here. (We only keep genes with Entrez ID). 
```{r message=FALSE,warnings=FALSE}
#load processed biomaRt mmu and hsa gene mapping
data("mmu_hsa_mapping")  
#map specificity score of mmu genes to hsa genes
#this step should be done not before cal_sscore()
facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
#calculate global statics
facs.sce = add_glob_stats(facs.sce, stats = c("det_cell_num","ave_exp_ct","max_exp_ct")) #based on the information to subset genes 
#or you can add some more statistics yourself
```

## Cell-type enrichment
Finally the cell type specificity score can be used to determine cell type-level trait association. `load_zscore()` function can be easily applied to obtain the trait-level Z-score data frame. The trait name will be automatically assigned based on the file name of the Z-score file (unless thhe `name` parameter is specified).
```{r}
#load MAGMA z-score file
t2d_zscore = load_zscore("/grain/ql29/ad-cell-enrich/data/gwas/new_tm_gs/zscore/T2D_2.genes.out")
mdd_zscore = load_zscore("/grain/ql29/ad-cell-enrich/data/gwas/new_tm_gs/zscore/MDD.genes.out")
ra_zscore = load_zscore("/grain/ql29/ad-cell-enrich/data/gwas/new_tm_gs/zscore/RA.genes.out")
#perform cell type enrichment analysis 
facs.sce = cal_ct_asso(facs.sce, t2d_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
facs.sce = cal_ct_asso(facs.sce, mdd_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
facs.sce = cal_ct_asso(facs.sce, ra_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
```

## Visualization
Final we can visualize the results. The plot is a `ggplot` object and could be further customized. 
If you would like to add some grouping to the plot, you may use `add_cell_anno()` function to add the cell type annotation to the enrichment results and visualize with the `group_by` argument. 
```{r,fig.width=8, fig.height=10, fig.align = 'center'}
#plot
f1 = plot_asso(facs.sce, asso_model = "linear",trait="T2D_2",plot_top_option = "rank<=15") + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f2 = plot_asso(facs.sce, asso_model = "linear",trait = "MDD", plot_top_option = "rank<=15") + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5))
f1/f2
```


```{r,fig.width=8, fig.height=10,fig.align = 'center'}
#if you would like to add more to the plot, for example, the tissue type
celltype_tissue = colData(facs.sce) %>% as_tibble() %>%  distinct(cluster_name, tissue) #annotation
facs.sce = add_ct_anno(facs.sce,  celltype_tissue, match_col="cluster_name")
#plot for the two
f3 = plot_asso(facs.sce, asso_model = "linear",trait="T2D_2", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f4 = plot_asso(facs.sce, asso_model = "linear",trait="MDD",group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5)) 
f3/f4
#you can also plot like FDR<0.05
```


## Varying background cell types
When calculating specificity score, the choice of background cells for a cell type is crucial. By default all cells of the other cell types are treated as the background cell type. But for these cells that are quite similar to each other (for example, cell types of an ontology that are either descendant or ancestor node in the cell ontology tree) this may cancel out the gene specificity score. The `out_group_mat` parameter of the `cal_sscore` function may be used to describe what cell types should be regarded as the background cells for a cell type, in a binary adjacency matrix format,  with each entry in the matrix indicating whether the corresponding cell type in the column is the background cells for cell type in the row. Here is an example on how to utilized an annotated cell ontology relationship to define background cells by removing cell types of either descendant or ancestor node in the tree.
```{r,fig.width=8, fig.height=10, fig.align = 'center'}
#load the annotated cell ontology table  #this step is performed using external python session since obonet is only supported in python
co_anno_table = read.csv("/grain/ql29/ad-cell-enrich/data/expr/Tabula_muris/cell_ontology_annotated_new_all.csv") %>% as_tibble()
#create the adjacency matrix
co_out_mat = co_anno_table %>%
  right_join(as.data.frame(colData(facs.sce)) %>% distinct(cluster_name, cell_ontology_id), by=c("cl_term" = "cell_ontology_id")) %>% #join annotation
  filter(cluster_name %in% names(get_seismic_slot(facs.sce, "group_info")[["cell_num"]])) %>%  #filter cell types that exist in the final results
  mutate(cluster_name = factor(cluster_name, levels = sort(cluster_name))) %>% 
  arrange(cluster_name) %>% #make sure the matrix is in the same order of the sorted cluster names
  apply(., 1, function(x) !grepl(pattern=x[1], x=.$similar_cl_term, fixed=T) & x[1]!=.$cl_term )  %>%
  set_rownames(sort( names(get_seismic_slot(facs.sce, "group_info")[["cell_num"]] ))) %>%
  set_colnames(sort( names(get_seismic_slot(facs.sce, "group_info")[["cell_num"]] )))
#calculate specificity score, translate gene id and perform association analysis
facs.sce = cal_sscore(data_obj = facs.sce, out_group_mat =  co_out_mat)  #in this case the specificity score will still be mouse symbol as the data matrix
facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
facs.sce = cal_ct_asso(facs.sce, t2d_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")
facs.sce = cal_ct_asso(facs.sce, mdd_zscore, gene_filter_setting = "det_cell_num>=10& ave_exp_ct > 0.1& max_exp_ct>0.1")

#final plot
f5 = plot_asso(facs.sce, asso_model = "linear", trait="T2D_2",group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with T2D") + theme(axis.text.x=element_text(size=5)) 
f6 = plot_asso(facs.sce, asso_model = "linear",trait="MDD", group="tissue", plot_top_option = "rank<=15") + ggsci::scale_fill_npg() + ggtitle("Associated cell types with MDD") + theme(axis.text.x=element_text(size=5)) 
f5/f6
```
Here the results are quite similar to the former ones (without specifying background cells).

seismicGWAS is also able to extract the most influential genes for a significant trait-cell type association pair. For example, to extract the most inflential genes for the association between pancreatic beta cells and type II diabetes.
```{r}
#top genes 
top_inf_genes = gene_inf_measure(facs.sce, gene_zscore_df = t2d_zscore, trait_name = "T2D_2", cell_type = "Pancreas.beta cell")
#import the library for annotation
library(org.Hs.eg.db)
top_inf_genes = top_inf_genes %>% 
  mutate(hsa_symbol = mapIds(org.Hs.eg.db, keys = hsa_entrez, keytype = "ENTREZID", column = "SYMBOL"))
plot_gene_inf(top_inf_genes, gene_label_column = "hsa_symbol", num_top_gene_label = 10,label_repel = T, 
              extra_labels = top_inf_genes  %>%filter(influential) %>% slice_sample(n=10) %>% pull(hsa_symbol) ) #if other extra symbols should be added
```
For example, the top influential gene is SLC30A8, which is responsible for a zinc transportation into pancreatic beta-cells. The function of the top genes can be also analyzed using gene set enrichment. For example, [clusterProfiler package](https://guangchuangyu.github.io/software/clusterProfiler/) provides a great interface for functional gene set enrichment.
```{r}
#import the library
library(clusterProfiler)
#GO enrichment
go_enrichment = enrichGO(gene = top_inf_genes %>% filter(influential) %>% pull(hsa_entrez), OrgDb = org.Hs.eg.db, keyType = "ENTREZID",ont = "BP",readable = T)
head(as.data.frame(go_enrichment),10)
```

seismicGWAS also provides functions for easily accessing to other MAGMA-based cell-type enrichment frameworks. To print out tables for MAGMA-specificity (S-MAGMA) or FUMA analysis and then use MAGMA for the analysis, firstly the CPM/logCPM assays have to be obtained and then the output tables are created. Note that for the original [S-MAGMA](https://www.nature.com/articles/s41588-020-0610-9)(gene set analysis) and [FUMA](https://www.nature.com/articles/s41467-017-01261-5) papers, CPM and logCPM (or logcounts) assays are used respectively.
```{r}
#FUMA uses logcpm assay and MAGMA uses cpm assay
assay(facs.sce,"cpm") = scuttle::calculateCPM(facs.sce)
#calculate mean expression
facs.sce = cal_stat(data_obj = facs.sce, meta_data = as.data.frame(colData(facs.sce)), group = "cluster_name",assay_name = "cpm", mean_only = TRUE) #only need cell type mean for later 
#map mmu genes to hsa genes
facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
#write.out
print_exp_tbl(facs.sce, "MAGMA", main_table_path = "/grain/ql29/ad-cell-enrich/data/test.magma.txt",aux_table_path = "/grain/ql29/ad-cell-enrich/data/aux.magma.txt")

#if FUMA
facs.sce=  scuttle::logNormCounts(facs.sce, assay.type = "cpm",name="logcpm")
facs.sce = cal_stat(data_obj = facs.sce, meta_data = as.data.frame(colData(facs.sce)), group = "cluster_name",assay_name = "logcpm")
facs.sce = trans_mmu_to_hsa_stat(facs.sce, gene_mapping_table=mmu_hsa_mapping, from="mmu_symbol", to="hsa_entrez")
print_exp_tbl(facs.sce, "FUMA", main_table_path = "/grain/ql29/ad-cell-enrich/data/test.fuma.txt",aux_table_path = "/grain/ql29/ad-cell-enrich/data/aux.fuma.txt")
```

Also seismicGWAS provides several tool functions, here are some of them.
```{r}
#get the log and overall information of the running
seismic_summary_info(facs.sce, verbose = T) #if you specificy "info_to_return = T", a lisf of the information will be printed out.
```
```{r}
#print out results
res_df = get_ct_asso(facs.sce, trait_name = "all",asso_model = "linear", merge_output = T)
head(res_df)
```
```{r}
#delete all previous analysis and restart
facs.sce = reset_seismic_analysis(facs.sce)
```

